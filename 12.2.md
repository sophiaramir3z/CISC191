# Activity 12.2: Merge sort

## My Flowchart:
<img width="1024" height="768" alt="Brown Pastel Flowchart Diagram Graph Template (3)" src="https://github.com/user-attachments/assets/cc48e5bd-037d-4b60-80f1-c2e20ec7ed22" />

## My challenges in performing the lab:
The biggest challenge for me was keeping track of how the recursion flows in merge sort. It can be confusing at first because the algorithm splits the array many times before anything is actually merged, 
so I had to slow down and trace the calls step-by-step. Another challenge was implementing the merge function cleanly since it requires multiple pointers, a temporary array, and careful index management. 
It was also tricky to count comparisons correctly without accidentally counting operations that are not comparisons. Finally, debugging required printing intermediate states to make sure the recursive calls 
were working in the correct order. Once I understood the divide-and-conquer pattern from the reading, everything fell into place, and the code became much easier to follow.

## My code:
```java
import java.util.Scanner;

public class MergeSortLab {

    static int comparisons = 0;

    public static void merge(int[] numbers, int i, int j, int k) {
        int mergedSize = k - i + 1;
        int[] merged = new int[mergedSize];

        int leftPos = i;
        int rightPos = j + 1;
        int mergePos = 0;

        // Merge the two sub-arrays
        while (leftPos <= j && rightPos <= k) {
            comparisons++; // count comparison

            if (numbers[leftPos] < numbers[rightPos]) {
                merged[mergePos] = numbers[leftPos];
                leftPos++;
            } else {
                merged[mergePos] = numbers[rightPos];
                rightPos++;
            }
            mergePos++;
        }

        // Copy any remaining left side
        while (leftPos <= j) {
            merged[mergePos] = numbers[leftPos];
            leftPos++;
            mergePos++;
        }

        // Copy any remaining right side
        while (rightPos <= k) {
            merged[mergePos] = numbers[rightPos];
            rightPos++;
            mergePos++;
        }

        // Write merged array back into the original array
        for (int m = 0; m < mergedSize; m++) {
            numbers[i + m] = merged[m];
        }
    }

    public static void mergeSort(int[] numbers, int i, int k) {
        if (i < k) {
            int j = (i + k) / 2;

            mergeSort(numbers, i, j);        // Sort left half
            mergeSort(numbers, j + 1, k);    // Sort right half

            merge(numbers, i, j, k);         // Merge halves
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int size = sc.nextInt();
        int[] numbers = new int[size];

        for (int i = 0; i < size; i++) {
            numbers[i] = sc.nextInt();
        }

        // Print unsorted array
        System.out.print("unsorted: ");
        for (int n : numbers) {
            System.out.print(n + " ");
        }
        System.out.println("\n");

        mergeSort(numbers, 0, numbers.length - 1);

        // Print sorted array
        System.out.print("sorted:   ");
        for (int n : numbers) {
            System.out.print(n + " ");
        }
        System.out.println();

        System.out.println("comparisons: " + comparisons);
    }
}
```

## Explanation Video:
https://sdccd.us-west-2.instructuremedia.com/embed/65f2b99f-da1e-491e-a7dd-580a804f6ff5
## By Sophia Ramirez
